/* Autogenerated file. Do not edit manually. */

/* tslint:disable */
/* eslint-disable */

/*
  Fuels version: 0.49.1
  Forc version: 0.40.1
  Fuel-Core version: 0.19.1
*/

import type {
  BigNumberish,
  BN,
  BytesLike,
  Contract,
  DecodedValue,
  FunctionFragment,
  Interface,
  InvokeFunction,
} from 'fuels';

import type { Option, Enum } from "./common";

export enum AuthorizationErrorInput { SenderNotOperator = 'SenderNotOperator' };
export enum AuthorizationErrorOutput { SenderNotOperator = 'SenderNotOperator' };
export type IdentityInput = Enum<{ Address: AddressInput, ContractId: ContractIdInput }>;
export type IdentityOutput = Enum<{ Address: AddressOutput, ContractId: ContractIdOutput }>;
export enum MarketErrorInput { InvalidRoundId = 'InvalidRoundId', InvalidClosingTime = 'InvalidClosingTime', MarketNotYetOpen = 'MarketNotYetOpen', RoundNotYetFinalized = 'RoundNotYetFinalized', PreviousRoundNotFinalized = 'PreviousRoundNotFinalized', InvalidReward = 'InvalidReward', ErrorClaimingReward = 'ErrorClaimingReward', MarketInitializedAlready = 'MarketInitializedAlready' };
export enum MarketErrorOutput { InvalidRoundId = 'InvalidRoundId', InvalidClosingTime = 'InvalidClosingTime', MarketNotYetOpen = 'MarketNotYetOpen', RoundNotYetFinalized = 'RoundNotYetFinalized', PreviousRoundNotFinalized = 'PreviousRoundNotFinalized', InvalidReward = 'InvalidReward', ErrorClaimingReward = 'ErrorClaimingReward', MarketInitializedAlready = 'MarketInitializedAlready' };
export enum PositionErrorInput { NoPositionFoundInRound = 'NoPositionFoundInRound', PositionExistForCallerInRound = 'PositionExistForCallerInRound', NoValidPositionInRound = 'NoValidPositionInRound' };
export enum PositionErrorOutput { NoPositionFoundInRound = 'NoPositionFoundInRound', PositionExistForCallerInRound = 'PositionExistForCallerInRound', NoValidPositionInRound = 'NoValidPositionInRound' };
export enum RoundErrorInput { NotYetTimeToFinalize = 'NotYetTimeToFinalize', FinalizedAlready = 'FinalizedAlready', EntryClosed = 'EntryClosed', ClosedAlready = 'ClosedAlready' };
export enum RoundErrorOutput { NotYetTimeToFinalize = 'NotYetTimeToFinalize', FinalizedAlready = 'FinalizedAlready', EntryClosed = 'EntryClosed', ClosedAlready = 'ClosedAlready' };

export type AddressInput = { value: string };
export type AddressOutput = AddressInput;
export type ContractIdInput = { value: string };
export type ContractIdOutput = ContractIdInput;
export type NewRoundEventInput = { round_id: BigNumberish, opening_time: BigNumberish, closing_time: BigNumberish, entry_deadline: BigNumberish };
export type NewRoundEventOutput = { round_id: BN, opening_time: BN, closing_time: BN, entry_deadline: BN };
export type PositionInput = { wager: BigNumberish, option: BigNumberish, price: BigNumberish };
export type PositionOutput = { wager: BN, option: number, price: BN };
export type PredictedEventInput = { account: IdentityInput, round_id: BigNumberish, price: BigNumberish, wager: BigNumberish, option: BigNumberish };
export type PredictedEventOutput = { account: IdentityOutput, round_id: BN, price: BN, wager: BN, option: number };
export type RewardClaimInput = { account: IdentityInput, amount: BigNumberish };
export type RewardClaimOutput = { account: IdentityOutput, amount: BN };
export type RoundInput = { opening_time: BigNumberish, closing_time: BigNumberish, entry_deadline: BigNumberish, closing_price: BigNumberish, total_wager: BigNumberish, percentage_reward: BigNumberish, is_finalized: boolean };
export type RoundOutput = { opening_time: BN, closing_time: BN, entry_deadline: BN, closing_price: BN, total_wager: BN, percentage_reward: number, is_finalized: boolean };
export type RoundFinalizedEventInput = { round_id: BigNumberish, total_wager: BigNumberish, closing_price: BigNumberish };
export type RoundFinalizedEventOutput = { round_id: BN, total_wager: BN, closing_price: BN };

export type MarketAbiConfigurables = {
  OPERATOR: IdentityInput;
};

interface MarketAbiInterface extends Interface {
  functions: {
    claim_reward: FunctionFragment;
    finalize_round: FunctionFragment;
    initialize: FunctionFragment;
    predict: FunctionFragment;
    start_next_round: FunctionFragment;
    get_account_position: FunctionFragment;
    get_last_round: FunctionFragment;
    get_last_round_id: FunctionFragment;
    get_market_controller: FunctionFragment;
    get_market_reward: FunctionFragment;
  };

  encodeFunctionData(functionFragment: 'claim_reward', values: [BigNumberish]): Uint8Array;
  encodeFunctionData(functionFragment: 'finalize_round', values: [BigNumberish, BigNumberish]): Uint8Array;
  encodeFunctionData(functionFragment: 'initialize', values: [string]): Uint8Array;
  encodeFunctionData(functionFragment: 'predict', values: [BigNumberish, BigNumberish, BigNumberish, BigNumberish]): Uint8Array;
  encodeFunctionData(functionFragment: 'start_next_round', values: [BigNumberish, BigNumberish, BigNumberish]): Uint8Array;
  encodeFunctionData(functionFragment: 'get_account_position', values: [BigNumberish, IdentityInput]): Uint8Array;
  encodeFunctionData(functionFragment: 'get_last_round', values: []): Uint8Array;
  encodeFunctionData(functionFragment: 'get_last_round_id', values: []): Uint8Array;
  encodeFunctionData(functionFragment: 'get_market_controller', values: []): Uint8Array;
  encodeFunctionData(functionFragment: 'get_market_reward', values: []): Uint8Array;

  decodeFunctionData(functionFragment: 'claim_reward', data: BytesLike): DecodedValue;
  decodeFunctionData(functionFragment: 'finalize_round', data: BytesLike): DecodedValue;
  decodeFunctionData(functionFragment: 'initialize', data: BytesLike): DecodedValue;
  decodeFunctionData(functionFragment: 'predict', data: BytesLike): DecodedValue;
  decodeFunctionData(functionFragment: 'start_next_round', data: BytesLike): DecodedValue;
  decodeFunctionData(functionFragment: 'get_account_position', data: BytesLike): DecodedValue;
  decodeFunctionData(functionFragment: 'get_last_round', data: BytesLike): DecodedValue;
  decodeFunctionData(functionFragment: 'get_last_round_id', data: BytesLike): DecodedValue;
  decodeFunctionData(functionFragment: 'get_market_controller', data: BytesLike): DecodedValue;
  decodeFunctionData(functionFragment: 'get_market_reward', data: BytesLike): DecodedValue;
}

export class MarketAbi extends Contract {
  interface: MarketAbiInterface;
  functions: {
    claim_reward: InvokeFunction<[round_id: BigNumberish], void>;
    finalize_round: InvokeFunction<[round_id: BigNumberish, closing_price: BigNumberish], Option<RoundOutput>>;
    initialize: InvokeFunction<[oracle_feed_id: string], void>;
    predict: InvokeFunction<[round_id: BigNumberish, wager: BigNumberish, price: BigNumberish, option: BigNumberish], Option<PositionOutput>>;
    start_next_round: InvokeFunction<[opening_time: BigNumberish, closing_time: BigNumberish, entry_deadline: BigNumberish], Option<RoundOutput>>;
    get_account_position: InvokeFunction<[round_id: BigNumberish, account: IdentityInput], PositionOutput>;
    get_last_round: InvokeFunction<[], RoundOutput>;
    get_last_round_id: InvokeFunction<[], BN>;
    get_market_controller: InvokeFunction<[], ContractIdOutput>;
    get_market_reward: InvokeFunction<[], number>;
  };
}
